---
title: "Creating a Dataframe with Upsampled Meteorology and Testing NO2 Model"
output: 
  md_document:
    variant: markdown_github
---

# Setting Up Workspace 

First, we're going to import the libraries we need 

```{r message=FALSE, warning=FALSE}

library(tidyr)
library(dplyr)
library(lubridate) #setting dates for df
library(data.table) #to setnames
library(openair)

```

Also, from this day forward, I'm going to try using R projects. R projects apparently are directories where you keep all the files for a given R project, and it is convenient because you are able to use relative paths instead of absolute paths (handy for multiple people working on the same project). 

As two checks that we're in the right directory, I'm going to include a line that checks the name of the directory and imports a script using the relative path: 

```{r}
(getwd())
source("changebins.R")
```



# Creating Test Dataframe 

In this section, I will create a dataframe which merges sensor data and meteorological data, by upsampling the meteorological data. 

```{r}
sensorpath <- "sn45.csv"
asospath <- "asos2.csv"

#This function imports the data, gets the two datasets ready to merge, sets the timezone and merges them

sensor = read.csv(sensorpath, header=TRUE, fileEncoding="UTF-8-BOM") #import sensor file
asos = read.csv(asospath, header=TRUE, fileEncoding="UTF-8-BOM") #import meteorology file

#getting our sensor data ready
#setnames(sensor, old = c('timestamp_local'), new = c('date')) #renaming
sensor$date <- ymd_hms(sensor$date, tz="America/New_York") #parse datetime
sensor[, c("lat", "long", "X", "X.1")] <- list(NULL) #removing columns for speed
sensor$date <- round_date(sensor$date, unit="minute")


#asos$date <- parse_date_time(asos$date, "%y/%m/%d %H:%M", tz="America/New_York", locale = "C") #ymd doesn't recognize its format, so use parse_datetime

#asos$valid <- strptime(asos$valid, format = "%Y-%m-%d %H:%M",tz="America/New_York") 

asos$date <- as.POSIXct(asos$valid, format = "%Y-%m-%d %H:%M", tz = "America/New_York")
asos <- asos %>%
  setnames(old = c("drct", "sped"), new = c("wd", "ws")) %>% #rename
  complete(date = seq(from = min(date), to= max(date),  by = "1 min")) %>%#make 1 minute intervals
  fill(c("wd", "ws")) 
  
asos[!grepl("null", asos$ws),]
asos[!grepl("null", asos$wd),]
asos$wd <- as.numeric(asos$wd)
asos$ws <- as.numeric(asos$ws)
asos$ws <- asos$ws * (1609/3600)
asos[,c("tmpc", "valid", "station")] <- list(NULL)


  
#merging
finaldf <- merge(x = sensor, y = asos, by = "date", all = FALSE) #all=FALSE gets rid of datapoints if one of the two datasets don't have them


```


# Analyzing Eben's NO2 Model 

Below, I'll create a script to import and format Eben's NO2 model, then append it to the maind dataframe

```{r}
no2model <- read.csv("no2_HYBRID_045.txt") 
# the timestamp is given as seconds from some origin, so I'll deduce the origin
(sensor$date[1] - no2model$timestamp[1]) # it looks like these two df have the same length, so the origin should be the date subtracted by this
no2model$date <-  as_datetime(no2model$timestamp , origin = (sensor$date[1] - no2model$timestamp[1])) 
no2model$date <- round_date(no2model$date, unit = "minute")   #to merge with finaldf
no2model$timestamp <- NULL #excluding this variable

no2model <- rename(no2model, c("no2" = "no2model")) #renaming, for the merge

finaldf <- merge(x = finaldf, y = no2model, by = "date", all = FALSE)


```


Next, I'll check the specific times that Eben pointed out oscillations before, to see the change. 

First, I'll create dataframes for those times : 

```{r}

oct_dat <- selectByDate(
  finaldf,
  start = "5/10/2019",
  end = "17/10/2019"
)

oct_period1 <- selectByDate(finaldf,
                            start = "5/10/2019",
                            end = "8/10/2019")

oct6 <-selectByDate(finaldf, 
                    start = "6/10/2019",
                    end="6/10/2019"
                    ) 
septoct_period2 <- selectByDate(
  finaldf, 
  start = "20/9/2019", 
  end = "11/10/2019"
)

septoct_period3 <- selectByDate(
  finaldf,
  start = "20/9/2019",
  end = "28/9/2019"
)


```

Then, I'll plot it: 

```{r}

source("creategraph.R")

creategraph(sn= finaldf[4000:7000], date = finaldf$date[4000:7000], plot1 = finaldf$rh_manifold[4000:7000], plot2 = finaldf$no[4000:7000], plot3a = finaldf$no2.x[4000:7000], plot3b = finaldf$no2model[4000:7000])
```

It does look like it's following no trends, and disregarding RH trends. 

```{r}

creategraph(sn= finaldf[17000:20000], date = finaldf$date[17000:20000], plot1 = finaldf$rh_manifold[17000:20000], plot2 = finaldf$no[17000:20000], plot3a = finaldf$no2.x[17000:20000], plot3b = finaldf$no2model[17000:20000])

```

According to these two examples, the model seems to work well. During the meeting, I'll ask if it needs to be validated in some way that proves it validity (some statistically significant way).
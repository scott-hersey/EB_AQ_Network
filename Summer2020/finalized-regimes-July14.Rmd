---
title: " All Regime Code "
---

# Overview 

In this notebook, I compile all the regime code I created. I also fill in the code I created in the past to make it more complete, in other words, I finish all the code that I created so that all three versions will give all four regimes.

Update 7/21: As of now, only the regimes by runway activity has code to create all four regimes. it still needs to revised as well, because there seems to be missing points in the regimes.

# Setup 

First, I'll import necessary libraries, sensor data and flight data: 

```{r}
library(lubridate)
library(openair)
library(dplyr)
library(data.table)
```

```{r}
sn45 <- read.csv("data/sn45.csv") #this is the modified sensor data for SN 45, locally I am storing it in the data folder but it can be found on the Sensor Data dropbox
sn45$X <- NULL 
sn45$date <- as.POSIXct(sn45$date, format="%m/%d/%Y %H:%M",  tz = "America/New_York")
sn45 <- sn45[!(duplicated(sn45$date)), ]
```

```{r}
flightdf <- read.csv("data/finalflightdf.csv") #this is the modified and finalized dataframe with the flight data from FAA. This can also be found on the Sensor Data dropbox
flightdf$Date <- ymd_hms(flightdf$Date, tz = "America/New_York")
```


# Version 1: Minute-by-minute regimes 

Note: I don't have the code implemented for regime 1 and 4 for this version yet. 

```{r}
highres_regimes <- function(sn, flightdf, runwaystring){
  # sn -> sensor data 
  # flightdf -> flight dataframe 
  # runwaystring -> string that denotes the runway in question, ie : "22L"
  
  #create start time and end time for each datapoint in flight df (+/- 90 s)
  flightdf$starttime <- flightdf$Date - 90
  flightdf$endtime <- flightdf$Date + 90
  
  # arrival and departure
  A_runway <- flightdf %>%
  filter(Opr == "A", RW == runwaystring)
  
  D_runway <- flightdf %>%
  filter(Opr == "D", RW == runwaystring)
  
  require(data.table) #for foverlaps function
  
  #preparing data for foverlaps function
  sn$date <- ymd_hms(sn$date, tz="America/New_York")
  A_runway$Date <- ymd_hms(A_runway$Date, tz="America/New_York")
  A_runwayL$starttime <- ymd_hms(A_runway$starttime, tz="America/New_York")
  A_runway$endtime <- ymd_hms(A_runway$endtime, tz="America/New_York")
  
  D_runway$Date <- ymd_hms(D_runway$Date, tz="America/New_York")
  D_runway$starttime <- ymd_hms(D_runway$starttime, tz="America/New_York")
  D_runway$endtime <- ymd_hms(D_runway$endtime, tz="America/New_York")
  
  setnames(A_runway, old="Date", new="date")
  
  
  setDT(A_runway) #makes df into datatable without wasting memory
  setDT(sn)
  sn[, dummy:=date]

  setkey(A_runway, starttime, endtime) #telling foverlaps to look for times between starttime and endtime
  reg2 <- foverlaps(sn, A_runway, by.x=c("date", "dummy"), type ="within", nomatch=0L)[, dummy := NULL][] #executing foverlaps for arrivals
  
  #doing the same for departures
  setnames(D_runway, old="Date", new="date")
  
  setDT(D_runway) #makes df into datatable without wasting memory
  setDT(sn)
  sn[, dummy:=date]

  setkey(D_runway, starttime, endtime)
  reg3 <- foverlaps(sn, D_runway, by.x=c("date", "dummy"), type ="within", nomatch=0L)[, dummy := NULL][]
  
  sn_reglist <- list("reg2"= reg2, "reg3" = reg3) #you can't return multiple objects from R function, so put them in one list
  return(sn_reglist)
}
```





# Version 2: Regimes by periods of arrivals and departures 

Note that while the regime code is done, it seems like the number of points in the regimes is less than the amount of points in the original sensor dataframe.


```{r}
runwaystring <- "22R"
temp_runway <- flightdf %>%   filter(RW == runwaystring) # extracting flights from just the right runway

#setting up variables
curr_reg <- temp_runway$Opr[1] #current regime
intervals_list <- list() #list of intervals
opr_list <- list() #list of corresponding intervals
curr_start <- temp_runway$Date[1] #current time
i <- 1 # counter

#this for loop goes through each flight, and determines whether to create a new time range or keep going 

for (flightindex in 2:length(temp_runway$Date)){ #for each of the flights, starting at the second
  #first var to check : time 
  if (difftime(temp_runway[flightindex, "Date"], temp_runway[flightindex - 1, "Date"], units="mins")  <  30){
    #second check : operation 
    
      #first check if operation is the same 
      if (temp_runway[flightindex, "Opr"] == curr_reg){ # if it's the same regime, keep going
      next
      } 
      #if it's not, but it's only one plane making a difference 
      else{
        if(temp_runway[flightindex+1, "Opr"] == curr_reg | temp_runway[flightindex+2, "Opr"] == curr_reg){ #if there's only one, two or three of that given opr
        next #keep going
      }
      
      else{ #otherwise, record this time range and start recording the next one
      intervals_list<- c(intervals_list, list(interval(start=curr_start, end=temp_runway[flightindex-1, "Date"], tz = "America/New_York"))) # record what the interval is
      opr_list <- c(opr_list, curr_reg) #record which operation this interval corresponds to 
      #update variables
      i <- i+ 1  
      curr_start <- temp_runway[flightindex , "Date"]
      curr_reg <- temp_runway[flightindex , "Opr"] 
      }
        } 
      }


    
  else{ #if there's a gap in time
      intervals_list<- c(intervals_list, list(interval(start=curr_start, end=temp_runway[flightindex-1, "Date"], tz = "America/New_York"))) # record what the interval is
      opr_list <- c(opr_list, curr_reg) #record which operation this interval corresponds to  
      intervals_list<- c(intervals_list, list(interval(start=temp_runway[flightindex-1, "Date"], end=temp_runway[flightindex, "Date"], tz = "America/New_York"))) # record what the interval is
      opr_list <- c(opr_list, "Other") #record which operation this interval corresponds to 
      #update variables
      i <- i+ 1  
      curr_start <- temp_runway[flightindex , "Date"]
      curr_reg <- temp_runway[flightindex , "Opr"] 

  }
}
  

(intervals <-  do.call(rbind, Map(data.frame, intervals_list=intervals_list, Opr=opr_list))) #put the interval and operation lists together
print(intervals)

intervals_arrival <- filter(intervals, Opr == "A") #filter time ranges by arrivals
intervals_departures <- filter(intervals, Opr == "D") #same for departures
intervals_other <- filter(intervals, Opr == "Other") #same for departures
 
sn_arrivals <- sn45[which(sn45$date %within% intervals_arrival$intervals_list[1]) , ] #extracting all the sensor data in the first interval
for (indx in 2:length(intervals_arrival$intervals_list)){
  sn_arrivals <- rbind(sn_arrivals, sn45[which(sn45$date %within% intervals_arrival$intervals_list[indx]) , ]) 
}

sn_departures <- sn45[which(sn45$date %within% intervals_departures$intervals_list[1] ), ]
for (indx in 2:length(intervals_departures$intervals_list)){
  sn_departures <- rbind(sn_departures, sn45[which(sn45$date %within% intervals_departures$intervals_list[indx]) , ]) 
}

sn_other <- sn45[which(sn45$date %within% intervals_other$intervals_list[1] ), ]
for (indx in 2:length(intervals_other$intervals_list)){
  sn_other <- rbind(sn_other, sn45[which(sn45$date %within% intervals_other$intervals_list[indx] ), ]) 
}
```

```{r}
sn_reg1 <- filter(sn_other, wd > 170 & wd < 240)
sn_reg4 <- setdiff(sn_other, sn_reg1)
```

```{r}
write.csv(sn_reg1, "sn45_reg1.csv", row.names = F)
write.csv(sn_departures, "sn45_reg2_D.csv", row.names = F)
write.csv(sn_arrivals, "sn45_reg3_A.csv", row.names = F)
write.csv(sn_reg4, "sn45_reg4.csv", row.names = F)
```

Gut check that regimes are sound (they don't overlap and include all the datapoints):

```{r}
#check that all datapoints are included
print((nrow(selectByDate(sn45, start = "6/9/2019", end = "28/4/2020")) - nrow(sn45[which(sn45$date == "2020-04-28 21:56:00 EDT") : which(sn45$date == "2020-04-28 23:59:00 EDT"), ]) ) - (nrow(sn_departures) + nrow(sn_arrivals) + nrow(sn_reg1) + nrow(sn_reg4)))
#check nothing was lost when separating sn_other 
nrow(sn_other) == (nrow(sn_reg1) + nrow(sn_reg4))

#check that there's no overlap
Reduce(intersect, list(sn_departures$date,sn_arrivals$date, sn_reg1$date, sn_reg4$date ))

```



# Version 3: Hourly regimes 

Note that this version also doesn't have code to create regimes 1 and 4 yet.

```{r}
hourlytally <- function(runwaystring){
  #input which runway as a string , ie "22L"
  #this function will return an hourly dataset that describes LTO 
  
  hourlyactivity <- flightdf %>% #call the flight dataset
  filter(RW == runwaystring) %>% #filter by runway
  mutate(hourly = format(Date, format="%Y-%m-%d %H")) %>% #create datetime object that shows the hour
  group_by(hourly , Opr) %>% #group by hour and operation
  summarise(count = n() ) #how many counts of each operation during that hour 
  
  
  hourlyactivity$regimeflag <- ifelse( #create a flag column that marks which regime the hour is in 
    # if hourly data is unique (no takeoffs AND landings) and Opr is A -> regime 3
    (
    (hourlyactivity$Opr %in% c("A")) &
     (duplicated(hourlyactivity$hourly)) == FALSE & ( duplicated(hourlyactivity$hourly, fromLast=TRUE) == FALSE  ) ),
  3,
  # if hourly data is unique (no takeoffs AND landings) and Opr is D -> regime 2
    ifelse(
      (
   ( hourlyactivity$Opr %in% c("D")) &
   (duplicated(hourlyactivity$hourly)) == FALSE & ( duplicated(hourlyactivity$hourly, fromLast=TRUE) == FALSE  ) ),
      2,
   
   5 )) #if it's neither regime 2 or 3, set the flag to 5

  
  return(hourlyactivity)
}



```

```{r}
  hourly22R <- hourlytally("22R")
  
  #create monthly column 
  sn45$hourly <- format(sn45$date, format="%Y-%m-%d %H")
  
  #merge datasets based on match of hourly  
  reg2and3_45 <- merge(sn45, hourly22R, by = "hourly", all = FALSE)
  
  reg2_45 <- subset(reg2and3_45, regimeflag ==2)
  reg3_45 <- subset(reg2and3_45, regimeflag ==3)
  
  reg1_45 <- sn45 %>% filter(sn45$date %in% setdiff(sn45$date, reg2and3_45$date) & wd > 170 & wd < 240)
  reg4_45 <- sn45 %>% filter(sn45$date %in% setdiff(sn45$date, reg2and3_45$date) & sn45$date %in% setdiff(sn45$date, reg1_45$date) )


```


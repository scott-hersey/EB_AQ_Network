---
title: "Preliminary Regime-Making Code"

---

#Overview 

This notebook contains code that is my first successful pass at creating dataframes that represent regimes. 


#Setup 

```{r}
library(lubridate)
library(dplyr)
```


reading and setting up flight data and sensor data: 

```{r}
flightdf <- read.csv("finalflightdf.csv")
flightdf$X <- NULL
flightdf$Date <- ymd_hms(flightdf$Date, tz = "America/New_York")
```

```{r}
sn72 <- read.csv("sn72.csv")
sn72$X <- NULL
sn72$date <- ymd_hms(sn72$date)
```

#Method 1 (longer time frames) revisited

In this section, I revisit the first method we discussed. This was the method that observes hourly flight patterns, and correlates sensor data to it. 

As an overview, this method recreates the flight dataset, so that it is organized by both hour (given as year-month-day hour) as well as operation (Arrival, Departure). It counts how many occurrences of the operations happen per hour, and it gets rid of hourly data that has more than one type of activity. This is all wrapped up as a function, and can be called for any runway



```{r}

library(dplyr)

hourlytally <- function(runwaystring){
  #input which runway as a string , ie "22L"
  #this function will return an hourly dataset that describes LTO 
  
  hourlyactivity <- flightdf %>% #call the flight dataset
  filter(RW == runwaystring) %>% #filter by runway
  mutate(hourly = format(date, format="%Y-%m-%d %H")) %>% #create datetime object that shows the hour
  group_by(hourly , Opr) %>% #group by hour and operation
  summarise(count = n() ) #how many counts of each operation during that hour 
  
  
  hourlyactivity$regimeflag <- ifelse( #create a flag column that marks which regime the hour is in 
    # if hourly data is unique (no takeoffs AND landings) and Opr is A -> regime 3
    (
    (hourlyactivity$Opr %in% c("A")) &
     (duplicated(hourlyactivity$hourly)) == FALSE & ( duplicated(hourlyactivity$hourly, fromLast=TRUE) == FALSE  ) ),
  3,
  # if hourly data is unique (no takeoffs AND landings) and Opr is D -> regime 2
    ifelse(
      (
   ( hourlyactivity$Opr %in% c("D")) &
   (duplicated(hourlyactivity$hourly)) == FALSE & ( duplicated(hourlyactivity$hourly, fromLast=TRUE) == FALSE  ) ),
      2,
   
   5 )) #if it's neither regime 2 or 3, set the flag to 5

  
  return(hourlyactivity)
}

#creating dataframes for all runways mentioned
hourly22L <- hourlytally("22L")
#hourly22R <- hourlytally("22R")
#hourly9 <- hourlytally("9")
#hourly27 <- hourlytally("27")

```


This is the code that I added in today. I create an hourly column for the sensor data as well, and then I merge the datasets based on that variable. 

```{r}
#create monthly column 
sn72$hourly <- format(sn72$date, format="%Y-%m-%d %H")

#merge datasets based on match of hourly  
reg2_72 <- merge(sn72, hourly22L, by = "hourly", all = FALSE)
```



# Method 2 (Short timeframes) revisited

In this section, I revisit the second method we discussed, which was merging the flight and sensor data if the sensor reading is abs(90 seconds) from an LTO.

```{r}

#create start time and end time for each datapoint in flight df (+/- 90 s)
flightdf$starttime <- flightdf$Date - 90
flightdf$endtime <- flightdf$Date + 90

#22L arrival and departure
A_22L <- flightdf %>%
  filter(Opr == "A", RW == "22L")

D_22L <- flightdf %>%
  filter(Opr == "D", RW == "22L")

#22R arrival and departure
A_22R <- flightdf %>%
  filter(Opr == "A", RW == "22R")

D_22R <- flightdf %>%
  filter(Opr == "D", RW == "22R")
```



```{r}

require(data.table) # v1.9.0+

sn72$date <- ymd_hms(sn72$date, tz="America/New_York")
A_22L$Date <- ymd_hms(A_22L$Date, tz="America/New_York")
A_22L$starttime <- ymd_hms(A_22L$starttime, tz="America/New_York")
A_22L$endtime <- ymd_hms(A_22L$endtime, tz="America/New_York")
#setnames(A_22L, old="Date", new="date")


setDT(A_22L) #makes df into datatable without wasting memory
setDT(sn72)
sn72[, dummy:=date]
A_22L <- A_22L[, !duplicated(colnames(A_22L))]
#setkey(mydata, DateTime1, DateTime2)
setkey(A_22L, starttime, endtime)
mydata2 <- foverlaps(sn72, A_22L, by.x=c("date", "dummy"), type ="within", nomatch=0L)[, dummy := NULL][]

```


